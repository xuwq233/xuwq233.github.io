{"meta":{"title":"xuwq's blog","subtitle":"美女的事你少管","description":"啥都想学一学","author":"xuwq","url":"http://yoursite.com","root":"/"},"pages":[{"title":"about","date":"2021-12-08T08:08:40.000Z","updated":"2021-12-08T08:23:44.179Z","comments":true,"path":"about/index.html","permalink":"http://yoursite.com/about/index.html","excerpt":"","text":"前端开发但不完全是前端开发 不局限自己的技术可能性"},{"title":"tags","date":"2021-12-08T06:30:15.000Z","updated":"2021-12-08T08:24:16.374Z","comments":true,"path":"tags/index.html","permalink":"http://yoursite.com/tags/index.html","excerpt":"","text":""},{"title":"categories","date":"2021-12-08T06:33:19.000Z","updated":"2021-12-08T08:23:21.570Z","comments":true,"path":"categories/index.html","permalink":"http://yoursite.com/categories/index.html","excerpt":"","text":""}],"posts":[{"title":"简单的ES6笔记","slug":"ES6note","date":"2021-12-08T09:07:19.000Z","updated":"2021-12-08T08:24:00.001Z","comments":true,"path":"2021/12/08/ES6note/","link":"","permalink":"http://yoursite.com/2021/12/08/ES6note/","excerpt":"简单的ES6笔记var与letvar:当使用var时，变量被全局声明或者在function内被声明；预编译时有变量提升hoisting let:let也可以定义全局变量或者局部变量。除此之外，在block, statement, or expression内使用let声明全局变量，它的作用域会被限制在block, statement, or expression内。","text":"简单的ES6笔记var与letvar:当使用var时，变量被全局声明或者在function内被声明；预编译时有变量提升hoisting let:let也可以定义全局变量或者局部变量。除此之外，在block, statement, or expression内使用let声明全局变量，它的作用域会被限制在block, statement, or expression内。 ###let声明不会被提升 1234567891011function getValue(condition)&#123; //相当于var value; if(condition)&#123; var value = 'blue'; return value; &#125;else&#123; return value; &#125;&#125;console.log(getValue(true));//blueconsole.log(getValue(false));//undefined 预编译时，变量声明被提升到逻辑最前(未执行到赋值语句之前，在AO里value=undefined),而初始化操作留在原地。这就意味着在整个函数内部均可访问到value. 1234567891011function getValue(condition)&#123; if(condition)&#123; let value = 'blue'; return value; &#125;else&#123; //变量value在此处不存在 return null; &#125;&#125;console.log(getValue(true));//blueconsole.log(getValue(false));//null 变量value由关键字let声明，不再被提升到函数顶部，作用于被限制在if{}块内。condition为true的情况：执行流离开if块后，value立刻被销毁。condition为false的情况：永远不会声明并初始化value。 ###let禁止重复声明所以代码量较大的工程中使用let可以防止变量不小心被overwrite 1234var num = 123;var num ='abc';console.log(num);//abc 123var num = 123;let num = 'abc';//Uncaught SyntaxError: Identifier 'num' has already been declared 同一作用域内不能用let重复定义已经存在的标识符 1234567var num = 123;if(1)&#123; let num = 'abc'; console.log(num);//abc console.log(window.num);//123&#125;console.log(num);/123 此处的let是在if块内声明了新变量num（两个num所处执行期上下文不同，即作用域不同），因此不会报错；在if块的作用域链，let声明的num位于链首指向的区域，会优先访问，而var声明num位于全局对象上，只用使用window.num才可以访问到。if块执行结束后，let声明的num永远不会被访问到。 let与循环块级作用域12345678910var printNumTwo;for (var i = 0; i &lt; 3; i++) &#123; if (i === 2) &#123; printNumTwo = function() &#123; return i; &#125;; &#125;&#125;console.log(printNumTwo());//3console.log(i);//3 此处var定义的是全局变量i，i的值会随着for循环不断更新，printNumTwo执行时访问的是全局的i（已更新为3）. 12345678910let printNumTwo;for (let i = 0; i &lt; 3; i++) &#123; if (i === 2) &#123; printNumTwo = function() &#123; return i; &#125;; &#125;&#125;console.log(printNumTwo());//2console.log(i);//Uncaught ReferenceError: i is not defined let声明的i是块级作用域,只能在代码块中起作用，在js中一个{}中的语句也称为一个代码块，每次循环会产生一个代码块，每个代码块中的都是一个新的变量i;此处for循环语句创造出了三个不同的i（值为0，1，2）跳出for循环语句i就不存在了，所以访问i会显示未定义 for循环过程大致可以表示为： 12345678910111213//生成了三个代码块，为每次循环创建独立的变量&#123; let i = 0； //...&#125;&#123; let i = 1； //...&#125;&#123; let i = 2； //...&#125;","categories":[{"name":"ES6","slug":"ES6","permalink":"http://yoursite.com/categories/ES6/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/tags/JavaScript/"},{"name":"ES6","slug":"ES6","permalink":"http://yoursite.com/tags/ES6/"}]},{"title":"ajax","slug":"ajax","date":"2019-07-26T09:07:19.000Z","updated":"2021-12-08T08:23:54.185Z","comments":true,"path":"2019/07/26/ajax/","link":"","permalink":"http://yoursite.com/2019/07/26/ajax/","excerpt":"Ajax——Asynchronous JavaScript and XML导入对于form表单的提交，一旦提交，页面就会刷新，然后在新页面展示提交的结果——Web运行原理：一次HTTP请求对应一个页面 对应于传统的form提交方式，有很多的弊端，异步请求就应运而生 如果要让用户留在当前页面中，同时发出新的HTTP请求，就必须用JavaScript发送这个新请求，接收到数据后，再用JavaScript更新页面，这样一来，用户就感觉自己仍然停留在当前页面，但是数据却可以不断地更新。 用JavaScript写一个AJAX代码并不复杂，但是需要注意：AJAX是异步请求，也就是说，要通过回调函数来判断和操作","text":"Ajax——Asynchronous JavaScript and XML导入对于form表单的提交，一旦提交，页面就会刷新，然后在新页面展示提交的结果——Web运行原理：一次HTTP请求对应一个页面 对应于传统的form提交方式，有很多的弊端，异步请求就应运而生 如果要让用户留在当前页面中，同时发出新的HTTP请求，就必须用JavaScript发送这个新请求，接收到数据后，再用JavaScript更新页面，这样一来，用户就感觉自己仍然停留在当前页面，但是数据却可以不断地更新。 用JavaScript写一个AJAX代码并不复杂，但是需要注意：AJAX是异步请求，也就是说，要通过回调函数来判断和操作 XMLHttpRequest对象在现在的浏览器上AJAX主要依靠XMLHttpRequest对象下面是它的主要属性和方法： readyState属性readyState属性标识了当前对象正处于什么状态可以通过该属性的访问，来判断此次请求的状态然后做出相应的操作 responseText属性目前为止为服务器接收到的响应体（不包括头部），或者如果还没有接收到数据的话，就是空字符串。 如果 readyState 小于 3，这个属性就是一个空字符串。当 readyState 为 3，这个属性返回目前已经接收的响应部分。如果 readyState 为 4，这个属性保存了完整的响应体。 如果响应包含了为响应体指定字符编码的头部，就使用该编码。否则，假定使用 Unicode UTF-8 responseXML属性用来描述被XMLHttpRequest解析后的XML文档的属性只有当readyState属性为4，并且响应头部的Content-type的MIME类型被指定为XML（text/xml,application/xml）时，该属性才会有值并且被解析为一个XML文档，否则该属性值为null；若回传的XML文档结构不良或者未完成回传，该属性值也会为null status属性描述了HTTP状态代码注意：只有readyState属性值为3（正在接收）或者4（已加载）时，才能对该属性进行访问。如果在readyState小于3时进行访问会引发一个异常 statusText属性描述了HTTP状态码文本，对status的解释注意点同上 onreadystatechange事件每当readyState属性值发生改变时，就会触发，一般通过该事件触发回传处理函数 open()方法初始化XMLHttpRequest对象语法：open(method,uri,async,username,password) method是必需的，大写，用来指定发送请求的HTTP方法（GET,POST,PUT,DELETE,HEAD） uri参数用于指定XMLHttqRequest对象把请求发送到的服务器相应的URI，该地址会被自动解析为绝对路径 async true：异步 false：同步 默认true username password 服务器验证访问用户的情况 send()方法将请求发送异步请求：send()调用后立即返回；同步请求：中断直到请求返回send()方法必须在redyState属性值为1时，即调用open()方法以后才能调用；调用send()方法后到收到响应信息前，readyState为2；开始收到响应信息，为3；响应接收完毕，为4 abort()方法暂停一个HttpRequest的请求发送或者HttpResponse的接收，并将XMLHttpRequest对象设置为初始化状态 setRequestHeader()方法设置请求头部信息readyState状态为1时，即调用open()方法后调用，否则返回异常setRequestHeader(header,value) getResponseHeader()方法检索响应的头部值readyState状态为3或4时调用，否则返回空字符串 AJAX实例12345678910111213141516171819202122232425262728293031323334353637&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;meta charset=\"utf-8\"&gt;&lt;script&gt;function getData()&#123; var xhr; if (window.XMLHttpRequest) &#123; // IE7+, Firefox, Chrome, Opera, Safari 浏览器执行代码 xhr=new XMLHttpRequest(); &#125; else &#123; // IE6, IE5 浏览器执行代码 xhr=new ActiveXObject(\"Microsoft.XMLHTTP\"); &#125; xhr.onreadystatechange=function() &#123; if (xhr.readyState==4 &amp;&amp; xhr.status==200) &#123; document.getElementById(\"myDiv\").innerHTML=xhr.responseText; &#125; &#125; xhr.open(\"GET\",\"http://47.103.10.220:8001/article/listAllArticle\",true); xhr.send();&#125;&lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;div id=\"myDiv\"&gt;&lt;h2&gt;&lt;/h2&gt;&lt;/div&gt;&lt;button type=\"button\" onclick=\"getData()\"&gt;获取内容&lt;/button&gt;&lt;/body&gt;&lt;/html&gt; jQuery中的AJAXload()方法载入远程HTML代码并插入DOM中语法 1$(selector).load(URL,data,callback); 参数名称 类型 说明 url String 请求HTML页面的URL地址 data（可选） Object 发送至服务器的key/value数据 callback（可选） Function 请求完成时的回调函数，无论请求成功或失败 可选的 callback 参数规定当 load() 方法完成后所要允许的回调函数。回调函数可以设置不同的参数： responseTxt - 包含调用成功时的结果内容 statusTXT - 包含调用的状态 xhr - 包含 XMLHttpRequest 对象 load()回调函数示例 123456789$(\"button\").click(function()&#123; $(\"#myDiv\").load(\"http://47.103.10.220:8001/article/listAllArticle\", function(responseTxt,statusTxt,xhr)&#123; if(statusTxt==\"success\") alert(\"加载成功！\"); if(statusTxt==\"error\") alert(\"Error: \"+xhr.status+\": \"+xhr.statusText); &#125;);&#125;); $.get()方法$.get()是jQuery中的全局函数 $.get() 方法通过 HTTP GET 请求从服务器上请求数据语法 1$.get(URL[,data][,callback][,type]); 请求成功时回调函数（只有当Response的返回状态是success才调用该方法）自动将请求结果（data）和状态（textStatus）传递给该方法回调函数 1234function(data,textStatus)&#123; //data 返回的内容，可以是HTML片段，XML，JSON等 //textStatus 请求状态：success error notmodified timeout四种&#125; $.post()方法$.post() 是jQuery中的全局函数 $.post() 方法通过 HTTP POST 请求从服务器上请求数据 1$.post(URL[,data][,callback][,type]); GET和POST对比查询字符串（名称/值对）是在 GET 请求的 URL 中发送的 1/test/demo_form.asp?name1=value1&amp;name2=value2 查询字符串（名称/值对）是在 POST 请求的 HTTP 消息主体中发送的 123POST /test/demo_form.asp HTTP/1.1Host: w3schools.comname1=value1&amp;name2=value2 这是两者最大也是最本质的区别之一更多区别参见：w3c $.getScript()方法动态创建&lt; script &gt;标签 123$.getScript('example.js',function()&#123; //.js成功载入后执行的回调函数&#125;) $.getJson()方法动态加载JSON文件 123$.getJson('example.json',function(data)&#123; //data:返回数据&#125;) $.ajax()方法$.jax()是jQuery最底层的Ajax实现 1$.ajax(options) Ajax方法中常用参数 1.url:要求为String类型的参数，（默认为当前页地址）发送请求的地址。 2.type:要求为String类型的参数，请求方式（post或get）默认为get。注意其他http请求方法，例如put和delete也可以使用，但仅部分浏览器支持。 3.timeout:要求为Number类型的参数，设置请求超时时间（毫秒）。此设置将覆盖$.ajaxSetup()方法的全局设置。 4.async:要求为Boolean类型的参数，默认设置为true，所有请求均为异步请求。如果需要发送同步请求，请将此选项设置为false。注意，同步请求将锁住浏览器，用户其他操作必须等待请求完成才可以执行。 5.cache:要求为Boolean类型的参数，默认为true（当dataType为script时，默认为false），设置为false将不会从浏览器缓存中加载请求信息。 6.data:要求为Object或String类型的参数，发送到服务器的数据。如果已经不是字符串，将自动转换为字符串格式。get请求中将附加在url后。防止这种自动转换，可以查看 processData选项。对象必须为key/value格式，例如{foo1:”bar1”,foo2:”bar2”}转换为&amp;foo1=bar1&amp;foo2=bar2。如果是数组，JQuery将自动为不同值对应同一个名称。例如{foo:[“bar1”,”bar2”]}转换为&amp;foo=bar1&amp;foo=bar2。 7.dataType:要求为String类型的参数，预期服务器返回的数据类型。如果不指定，JQuery将自动根据http包mime信息返回responseXML或responseText，并作为回调函数参数传递。可用的类型如下：xml：返回XML文档，可用JQuery处理。html：返回纯文本HTML信息；包含的script标签会在插入DOM时执行。script：返回纯文本JavaScript代码。不会自动缓存结果。除非设置了cache参数。注意在远程请求时（不在同一个域下），所有post请求都将转为get请求。json：返回JSON数据。jsonp：JSONP格式。使用SONP形式调用函数时，例如myurl?callback=?，JQuery将自动替换后一个“?”为正确的函数名，以执行回调函数。text：返回纯文本字符串。 8.beforeSend：要求为Function类型的参数，发送请求前可以修改XMLHttpRequest对象的函数，例如添加自定义HTTP头。在beforeSend中如果返回false可以取消本次ajax请求。XMLHttpRequest对象是惟一的参数。 function(XMLHttpRequest){ this; //调用本次ajax请求时传递的options参数 } 9.complete：要求为Function类型的参数，请求完成后调用的回调函数（请求成功或失败时均调用）。参数：XMLHttpRequest对象和一个描述成功请求类型的字符串。 function(XMLHttpRequest, textStatus){ this; //调用本次ajax请求时传递的options参数 } 10.success：要求为Function类型的参数，请求成功后调用的回调函数，有两个参数。 (1)由服务器返回，并根据dataType参数进行处理后的数据。 (2)描述状态的字符串。 function(data, textStatus){ //data可能是xmlDoc、jsonObj、html、text等等 this; //调用本次ajax请求时传递的options参数 } 11.error:要求为Function类型的参数，请求失败时被调用的函数。该函数有3个参数，即XMLHttpRequest对象、错误信息、捕获的错误对象(可选)。ajax事件函数如下： function(XMLHttpRequest, textStatus, errorThrown){ //通常情况下textStatus和errorThrown只有其中一个包含信息 this; //调用本次ajax请求时传递的options参数 } 12.contentType：要求为String类型的参数，当发送信息至服务器时，内容编码类型默认为”application/x-www-form-urlencoded”。该默认值适合大多数应用场合。 13.dataFilter：要求为Function类型的参数，给Ajax返回的原始数据进行预处理的函数。提供data和type两个参数。data是Ajax返回的原始数据，type是调用jQuery.ajax时提供的dataType参数。函数返回的值将由jQuery进一步处理。 function(data, type){ //返回处理后的数据 return data; } 14.global：要求为Boolean类型的参数，默认为true。表示是否触发全局ajax事件。设置为false将不会触发全局ajax事件，ajaxStart或ajaxStop可用于控制各种ajax事件。 12345678910111213141516$.ajax(&#123; type: \"GET\", url: \"test.json\", data: &#123;username:$(\"#username\").val(), content:$(\"#content\").val()&#125;, dataType: \"json\", success: function(data)&#123; $('#resText').empty(); //清空resText里面的所有内容 var html = ''; $.each(data, function(commentIndex, comment)&#123; html += '&lt;div class=\"comment\"&gt;&lt;h6&gt;' + comment['username'] + ':&lt;/h6&gt;&lt;p class=\"para\"' + comment['content'] + '&lt;/p&gt;&lt;/div&gt;'; &#125;); $('#resText').html(html); &#125; &#125;); 序列化元素serialize()方法该方法通过序列化表单值，创建标准的URL编码文本字符串，它的操作对象是代表表单元素集合的JQuery对象 1$(selector).serialize() serializeArray()方法将DOM元素序列化后，返回JSON格式的数据 1$(selector).serializeArray() $.param()方法对一个数组或对象按照key/value进行序列化 1$.param(obj) REFERENCES:W3C XMLHttpRequest","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/categories/JavaScript/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/tags/JavaScript/"},{"name":"Ajax","slug":"Ajax","permalink":"http://yoursite.com/tags/Ajax/"}]},{"title":"Hello World","slug":"hello-world","date":"2019-07-26T08:54:09.518Z","updated":"2021-12-08T06:42:25.566Z","comments":true,"path":"2019/07/26/hello-world/","link":"","permalink":"http://yoursite.com/2019/07/26/hello-world/","excerpt":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub.","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[]}],"categories":[{"name":"ES6","slug":"ES6","permalink":"http://yoursite.com/categories/ES6/"},{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/categories/JavaScript/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/tags/JavaScript/"},{"name":"ES6","slug":"ES6","permalink":"http://yoursite.com/tags/ES6/"},{"name":"Ajax","slug":"Ajax","permalink":"http://yoursite.com/tags/Ajax/"}]}